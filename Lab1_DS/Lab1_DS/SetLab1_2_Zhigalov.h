#pragma once
#include <string>
#include<random>
using namespace std;

struct Node {
	int value;
	Node* next;

};
struct Node2 {
	int val;
	Node* nexting;

};
/*
	1.	F1. Создание пустого множества. 
	Входные параметры: нет. 
	Выходные параметры: указатель на первый элемент списка, равный NULL.
*/
Node* createSetList();

/*
	2.	F2. Пустое множество? 
	Входные параметры: указатель на первый элемент списка. 
	Выходные параметры: логическое значение.
*/
bool emptySetList(Node* firstElement);

/*
	3.	F3. Проверка принадлежности элемента множеству. 
	Входные параметры: указатель на первый элемент списка, значение элемента. 
	Выходные параметры: логическое значение. Использовать F2.
*/
bool elemInSetList(Node* firstElement, int valaues);

/*
	4.	F4. Добавление нового элемента в множество. 
	Входные параметры: указатель на первый элемент списка, добавляемое в список значение. 
	Выходные параметры: указатель на первый элемент списка-результата. 
	Использовать F3. Ограничение: добавление осуществлять в начало списка.
*/
Node* addelem(Node* firstElement, int values);

/*
	5.	F5. Создание множества. 
	Входные параметры: количество элементов, интервал допустимых значений (от min до max). 
	Выходные параметры: указатель на первый элемент списка-результата. 
	Генерация значений – датчиком случайных чисел. 
	Использовать F4. 
	Требования: проверить возможность создания множества с заданными параметрами.
*/
Node* createSetList(int len, int min, int max, char setType);

/*
	6.	F6. Мощность множества. 
	Входные параметры: указатель на первый элемент списка. 
	Выходные параметры: целочисленное значение. 
	Использовать F2.
*/
int Power_SetList(Node* firstElement);

/*
	7.	F7. Вывод элементов множества. 
	Входные параметры: указатель на первый элемент списка, символ разделителя. 
	Выходные параметры: строка, содержащая элементы множества, разделенные символом разделителя. 
	Использовать F2. 
	Требования: в конце строки-результата разделитель стоять не должен
*/
string toString(Node* firstElement, char sym);

/*
	8.	F8. Удаление множества (очистка памяти, занимаемой списком). 
	Входные параметры: указатель на первый элемент списка. 
	Выходные параметры: указатель на первый элемент списка, равный NULL.
*/
Node* deleteSetList(Node* firstElement);
/*
   F9.Подмножество А - В.
   Входные параметры : два указателя на первые элементы списков – исходных множеств А и В.
   Выходные параметры :логическое значение True, если А является подмножеством В.Использовать F2, F6.
*/
bool isSubset(Node* A, Node* B);

/*
   F10.Равенство двух множеств А - В.
   Входные параметры : два указателя на первые элементы списков – исходных множеств А и В.
   Выходные параметры : логическое значение True, если А равно В.Использовать F9.
*/
bool equalSet(Node* firstElement_A, Node* firstElement_B );

/*
   F11.Объединение двух множеств.
   Входные параметры : два указателя на первые элементы списков – исходных множеств.
   Выходные параметры : указатель на первый элемент списка - результата.Использовать  F4(+использовать 3 множество).
*/
Node* unitySet(Node* firstElement_A, Node* firstElement_B);

/*
   F12.Пересечение двух множеств.
   Входные параметры : два указателя на первые элементы списков – исходных множеств.
   Выходные параметры : указатель на первый элемент списка - результата.Использовать F3, F4.
*/
Node* intersectionSet(Node* firstElement_A, Node* firstElement_B);

/*
   F13.Разность множеств.
   Входные параметры : два указателя на первые элементы списков – исходных множеств.
   Выходные параметры : указатель на первый элемент списка - результата.Использовать F3, F4.
*/
Node* differenceSet(Node* firstElement_A, Node* firstElement_B);

/*
   F14.Симметричная разность.
   Входные параметры : два указателя на первые элементы списков – исходных множеств.
   Выходные параметры : указатель на первый элемент списка - результата.Использовать F11, F12 и F13.
*/
Node* symmetrydifferentSet(Node* firstElement_A, Node* firstElement_B);

int random(int min, int max);//рандомный диапазон множества от 6 до 9 элементов